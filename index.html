<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Neon Snake — Play!</title>
<style>
  :root{
    --bg:#081226;
    --panel:#071029;
    --accent:#7c5cff;
    --accent2:#00e5ff;
    --muted:#9fb0c8;
    --danger:#ff6b6b;
    --tile: #0f2033;
  }
  *{box-sizing:border-box}
  body{
    margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,var(--bg), #02101a 70%);
    color:#eaf3ff;
    padding:20px;
  }

  .app{
    width:100%; max-width:920px; display:grid; gap:18px;
    grid-template-columns: 320px 1fr;
    align-items:start;
  }

  /* Responsive: stack on mobile */
  @media (max-width:820px){
    .app { grid-template-columns: 1fr; max-width:720px; }
  }

  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
    border-radius:14px; padding:16px; box-shadow: 0 10px 30px rgba(2,6,23,.6); border:1px solid rgba(255,255,255,.03);
  }

  .left { display:flex; flex-direction:column; gap:12px; min-height:200px; }
  h1{margin:0; font-size:20px; letter-spacing:0.02em}
  .subtitle{color:var(--muted); font-size:13px}
  .scoreboard{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .badge{background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#031026; padding:8px 10px; border-radius:10px; font-weight:700}

  /* Canvas holder */
  .game-wrap{background:linear-gradient(180deg, rgba(255,255,255,.01), rgba(255,255,255,.005)); border-radius:12px; padding:12px; display:flex; flex-direction:column; gap:10px; align-items:center; justify-content:center;}
  canvas{background: linear-gradient(180deg,var(--tile), #081b2b); border-radius:10px; box-shadow: inset 0 6px 30px rgba(0,0,0,.6); width:100%; height:auto; max-height:720px; display:block;}

  /* Controls (mobile) */
  .controls{display:flex; gap:8px; justify-content:space-between; align-items:center; width:100%}
  .touch-pad{display:grid; grid-template-columns: repeat(3, 64px); gap:8px; justify-content:center; align-items:center;}
  .btn{
    width:64px;height:64px;border-radius:12px;border:1px solid rgba(255,255,255,.04);
    background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.005));
    display:flex;align-items:center;justify-content:center;color:var(--muted);
    font-weight:700;user-select:none; touch-action:none;
  }
  .big-btn{width:100%; padding:12px 14px; border-radius:12px; background:linear-gradient(90deg,var(--accent),var(--accent2)); color:#031026; font-weight:800; border:none; cursor:pointer}
  .small{padding:8px 10px; font-size:13px}

  .footer-hint{font-size:13px;color:var(--muted)}

  /* Visual: grid overlay small */
  .grid-overlay{position:relative}
  .overlay-hint{position:absolute; top:10px; right:14px; font-size:12px; color:var(--muted)}
</style>
</head>
<body>
  <div class="app">
    <!-- Left panel: controls + info -->
    <div class="panel left">
      <div>
        <h1>Neon Snake</h1>
        <div class="subtitle">Retro fun with modern style — keyboard or touch controls.</div>
      </div>

      <div class="scoreboard">
        <div>Score: <span id="score" class="badge">0</span></div>
        <div>High: <span id="highscore" class="badge">0</span></div>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="startBtn" class="big-btn">Start</button>
        <button id="pauseBtn" class="big-btn small">Pause</button>
      </div>

      <div style="display:flex; gap:8px;">
        <button id="speedDown" class="btn small">- Speed</button>
        <button id="speedUp" class="btn small">+ Speed</button>
        <button id="resetHigh" class="btn small">Reset High</button>
      </div>

      <div style="margin-top:8px;">
        <div class="subtitle">Controls</div>
        <ul style="margin:6px 0 0 18px; color:var(--muted)">
          <li>Arrows / WASD to move</li>
          <li>Mobile: use on-screen arrows or swipe</li>
          <li>Eat food to grow — don't hit walls or yourself</li>
        </ul>
      </div>

      <div style="margin-top:8px;">
        <div class="subtitle">Settings</div>
        <div style="display:flex; gap:8px; margin-top:6px; align-items:center;">
          <label style="color:var(--muted)">Grid:
            <select id="gridSize" style="margin-left:6px; padding:6px; border-radius:8px; background:transparent; color:inherit;">
              <option value="15">15 x 15</option>
              <option value="20" selected>20 x 20</option>
              <option value="25">25 x 25</option>
              <option value="30">30 x 30</option>
            </select>
          </label>
          <label style="color:var(--muted)">Wrap:
            <input id="wrapToggle" type="checkbox" style="margin-left:6px">
          </label>
        </div>
      </div>

      <div style="margin-top:auto">
        <div class="footer-hint">Made for fun • Local high score saved in your browser</div>
      </div>
    </div>

    <!-- Right panel: game canvas -->
    <div class="panel game-wrap">
      <div style="display:flex; width:100%; justify-content:space-between; align-items:center;">
        <div class="subtitle">Play area</div>
        <div class="overlay-hint">Swipe or use arrows</div>
      </div>

      <div class="grid-overlay" style="width:100%;">
        <canvas id="game" width="600" height="600" aria-label="Snake game canvas"></canvas>
      </div>

      <!-- Touch controls for mobile -->
      <div style="width:100%; display:flex; justify-content:center; margin-top:6px;">
        <div class="controls" id="touchControls" style="max-width:420px;">
          <div class="touch-pad" id="touchPad">
            <div class="btn" data-dir="up">↑</div>
            <div class="btn" data-dir="up-right" style="visibility:hidden"></div>
            <div class="btn" data-dir="right">→</div>

            <div class="btn" data-dir="left">←</div>
            <div class="btn" data-dir="down" style="background:transparent; border:none; visibility:hidden"></div>
            <div class="btn" data-dir="down">↓</div>

            <div style="grid-column:1/span3; display:flex; gap:8px; justify-content:center; margin-top:6px;">
              <div class="btn" id="btnSpeed" style="width:auto">Speed x<span id="speedVal">1</span></div>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/*
  Neon Snake
  - Grid-based snake game with keyboard + touch input
  - localStorage for high score
  - Configurable grid size & wrap-around option
*/

(() => {
  // Elements
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('highscore');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const speedUp = document.getElementById('speedUp');
  const speedDown = document.getElementById('speedDown');
  const resetHigh = document.getElementById('resetHigh');
  const gridSizeSel = document.getElementById('gridSize');
  const wrapToggle = document.getElementById('wrapToggle');
  const speedVal = document.getElementById('speedVal');

  // Game state
  let grid = 20;
  let tileSize = 30;
  let snake = [];
  let dir = { x: 1, y: 0 }; // moving right initially
  let nextDir = null;
  let food = null;
  let score = 0;
  let high = parseInt(localStorage.getItem('neonSnakeHigh') || '0', 10);
  let running = false;
  let paused = false;
  let speed = 1; // multiplier
  let lastTick = 0;
  let tickInterval = 120; // ms per step at speed=1
  let wrap = false;

  highEl.textContent = high;

  // Resize canvas to keep square and responsive
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const minSide = Math.min(rect.width, window.innerHeight * 0.7);
    canvas.style.width = minSide + 'px';
    canvas.style.height = minSide + 'px';
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function initGame(resetScore = true) {
    grid = parseInt(gridSizeSel.value, 10);
    wrap = wrapToggle.checked;
    tileSize = Math.floor(canvas.width / grid);
    // Initialize snake in center
    const cx = Math.floor(grid/2);
    const cy = Math.floor(grid/2);
    snake = [{x: cx, y: cy}, {x: cx-1, y: cy}, {x: cx-2, y: cy}];
    dir = {x:1, y:0};
    nextDir = null;
    placeFood();
    if (resetScore) score = 0;
    scoreEl.textContent = score;
  }

  function placeFood() {
    let tries = 0;
    while (tries < 1000) {
      const fx = Math.floor(Math.random() * grid);
      const fy = Math.floor(Math.random() * grid);
      if (!snake.some(s => s.x === fx && s.y === fy)) {
        food = {x: fx, y: fy};
        return;
      }
      tries++;
    }
  }

  function step() {
    // Apply nextDir if set (prevents 180-degree)
    if (nextDir) {
      if (!(nextDir.x === -dir.x && nextDir.y === -dir.y)) {
        dir = nextDir;
      }
      nextDir = null;
    }

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // Wrap or check walls
    if (wrap) {
      head.x = (head.x + grid) % grid;
      head.y = (head.y + grid) % grid;
    } else {
      if (head.x < 0 || head.x >= grid || head.y < 0 || head.y >= grid) {
        gameOver();
        return;
      }
    }

    // Self-collision
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);

    // Eat food?
    if (food && head.x === food.x && head.y === food.y) {
      score += 10;
      if (score > high) {
        high = score;
        localStorage.setItem('neonSnakeHigh', String(high));
        highEl.textContent = high;
      }
      scoreEl.textContent = score;
      placeFood();
      // increase speed slightly every 50 points
      if (score % 50 === 0) {
        speed = Math.min(4, +(speed + 0.25).toFixed(2));
        speedVal.textContent = speed;
      }
    } else {
      snake.pop();
    }
  }

  function gameOver() {
    running = false;
    paused = false;
    alert(`Game Over! Score: ${score}`);
    initGame(true);
    draw();
  }

  // Drawing
  function drawGrid() {
    const w = canvas.width;
    const h = canvas.height;
    ctx.clearRect(0,0,w,h);
    // subtle background
    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0,'#072033');
    grad.addColorStop(1,'#051228');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    // small grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    for (let i=0;i<=grid;i++){
      ctx.beginPath();
      ctx.moveTo(i*tileSize,0);
      ctx.lineTo(i*tileSize,h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,i*tileSize);
      ctx.lineTo(w,i*tileSize);
      ctx.stroke();
    }
  }

  function draw() {
    // adapt drawing to actual displayed size to keep crisp squares
    const displayW = canvas.clientWidth;
    canvas.width = displayW;
    canvas.height = displayW;
    tileSize = Math.floor(canvas.width / grid);
    drawGrid();

    // draw food
    if (food) {
      drawCell(food.x, food.y, '#ffcf4d', true, '#e69a00');
    }

    // draw snake body
    for (let i=snake.length-1;i>=0;i--){
      const s = snake[i];
      const hue = 200 - Math.min(160, i*6);
      const color = i===0 ? 'linear-gradient' : `rgba(255,255,255,0.06)`;
      // head glow
      if (i===0) drawCell(s.x,s.y, '#7c5cff', true, '#00e5ff', 14);
      else drawCell(s.x,s.y, '#16405a', false, '#0f9bbf', 6);
    }
  }

  function drawCell(x,y, fill, glow=false, stroke='#000', blur=6){
    const px = x*tileSize;
    const py = y*tileSize;
    // glow effect
    if (glow) {
      ctx.save();
      ctx.shadowColor = stroke;
      ctx.shadowBlur = blur;
      ctx.fillStyle = fill;
      ctx.fillRect(px+2,py+2,tileSize-4,tileSize-4);
      ctx.restore();
    } else {
      ctx.fillStyle = fill;
      ctx.fillRect(px+2,py+2,tileSize-4,tileSize-4);
      // subtle border
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.strokeRect(px+2,py+2,tileSize-4,tileSize-4);
    }
  }

  // Main loop
  function loop(ts) {
    if (!running || paused) {
      lastTick = ts;
      requestAnimationFrame(loop);
      return;
    }
    if (!lastTick) lastTick = ts;
    const elapsed = ts - lastTick;
    const interval = Math.max(30, tickInterval / speed);
    if (elapsed >= interval) {
      step();
      draw();
      lastTick = ts;
    }
    requestAnimationFrame(loop);
  }

  // Input handling
  window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') setDir(0,-1);
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') setDir(0,1);
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') setDir(-1,0);
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') setDir(1,0);
    if (e.key === ' ' ) { // space to pause
      togglePause();
    }
  });

  function setDir(x,y) {
    nextDir = {x,y};
  }

  // Touch / swipe controls
  let touchStart = null;
  canvas.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY};
  }, {passive:true});
  canvas.addEventListener('touchend', (e) => {
    if (!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (Math.max(adx, ady) < 20) return;
    if (adx > ady) {
      setDir(dx > 0 ? 1 : -1, 0);
    } else {
      setDir(0, dy > 0 ? 1 : -1);
    }
    touchStart = null;
  }, {passive:true});

  // On-screen buttons
  document.querySelectorAll('[data-dir]').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const d = btn.getAttribute('data-dir');
      if (d === 'up') setDir(0,-1);
      if (d === 'down') setDir(0,1);
      if (d === 'left') setDir(-1,0);
      if (d === 'right') setDir(1,0);
    });
  });

  // Buttons
  startBtn.addEventListener('click', () => {
    running = true;
    paused = false;
    initGame(true);
    lastTick = 0;
    requestAnimationFrame(loop);
  });

  pauseBtn.addEventListener('click', togglePause);

  function togglePause() {
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }

  speedUp.addEventListener('click', () => {
    speed = Math.min(4, +(speed + 0.25).toFixed(2));
    speedVal.textContent = speed;
  });
  speedDown.addEventListener('click', () => {
    speed = Math.max(0.5, +(speed - 0.25).toFixed(2));
    speedVal.textContent = speed;
  });
  resetHigh.addEventListener('click', () => {
    if (confirm('Reset high score?')) {
      high = 0; localStorage.removeItem('neonSnakeHigh'); highEl.textContent = high;
    }
  });

  // When grid change or wrap toggled, re-init if running
  [gridSizeSel, wrapToggle].forEach(el => el.addEventListener('change', () => {
    if (running) initGame(true);
    draw();
  }));

  // start paused demo
  initGame(true);
  draw();

  // small auto-start option: uncomment to auto-start
  // running = true; requestAnimationFrame(loop);

})();
</script>
</body>
</html>
